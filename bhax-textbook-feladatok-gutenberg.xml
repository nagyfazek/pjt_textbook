<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>         
            <citation>PICI</citation>       
        </para>
        <para>
            II. heti előadás (11. oldal, az "1.2 Alapfogalmak" című rész):
        </para>
        <para>
            A programozási nyelveknek három szintje van: a gépi nyelv amelyek már a processzor nyelvére vannak lefordítva, az assembly szintű nyelv, azaz gépközeli nyelvek és a magas szintű nyelvek, mint például a java és C++. Minden forrás szöveget megfelelő kóddá kell alakítani, mivel minden processzor saját gépi nyelvvel rendelkezik. Erre két megoldás létezik: azinterpreteres és a fordítóprogramos. Az utóbbi megoldás a forrásszöveget lefordítja, így válik futtathatóvá, míg az előbbi esetében az interpretes soronként halad végig és olvasási sorrendben hajtja végig az utasításokat.A programozási nyelveknek van saját hivatkozási szabványa. Ebben vannak definiálva a szintaktikai és szemantikai szabályok, legtöbbször angolul. Vannak implementációk, amelyek operációs rendszereken interpreter megvalósítást jelent. Ezek nem kompatibilisek egymással. Létezhet egy operációs rendszeren több implementáció is, ezek sem mindig kompatibilisek egymással. Manapság a programozáshoz többnyire  IDE-ket használunk, amelyek grafikus programok, amelyekbe van beépített szövegszerkesztő, fordító és futtatórendszer.
        </para>
        <para>
            III. heti előadás (28. oldal, a "2.4. Adattípusok" című rész):
        </para>
        <para>
            Az adatabsztrakció első formája az adattípus. Az adattípus rendelkezik névvel, ami azonosítja a típust. Léteznek nem típusos és típusos programozási nyelvek. A típususosok engedik meg, hogy a programozó megadja a változók típusát,például a Java. A nem típusosok automatikusan adják meg a változó típusát,például a Python. Adattípusoknak két csoportja van, az egyszerű és az összetett. Az egyszerű adattípusokat nem lehet tovább bontani, míg az összetett típusokat lehet, például a struktúrákat.
        </para>
        <para>
            III. heti előadás (34. oldal, a "2.5. A nevesített konstans" című rész):
        </para>
        <para>
            A nevesített konstansok azt a célt szolgálják a programokban, hogy olyan nevet adjunk a konstansoknak, amely jelképezi a típusát és értékét, illetve másik célja, hogy többszöri használat esetén csak a megadásnál kelljen váloztatni az értékét. Ezeket mindig definiálni kell.
        </para>
        <para>
            III. heti előadás (35. oldal a "2.6. A változó" című rész):
        </para>
        <para>
            A változónak 4 komponense van: a név, az attribútomok, a cím és az érték. A név az egy azonosító, amit a  másik három komponens egy névhez rendeljük hozzá. A típus a legfőbb atribútom, mely a változó által felvett értéket határolja be. A változóhoz deklarációk segítségével rendelődnek az attribútumok. A deklarációnak több különböző fajtáit simerjük: Explicit deklaráció, Implicit deklaráció, Automatikus deklaráció. A változó értékének a helyét a változó címe határozza meg. A címrendelésnek 3 fajtáját ismerjük: a Statikus, a Dinamikus, és a programozó által vezérelt kiosztást. A változó értékét megadhatjuk értékadó utasítással vagy kezdőérték adással.
        </para> 
        <para>
            III. heti előadás (39. oldal, az "2.7. Alapelemek az egyes nyelvekben" című rész):
        </para>
        <para>
            C-ben az aritmetikai típusok az egyszerű típusok és a származtatottak az összetett típusok. A belső kódok alkotják a karakter típus elemeit. Logikai típus nincs ezért a hamis az int 0 és az igaz pedig az int 1. A void tartománya üres. A felsorolás típusok nem fedhetik egymást. Ugyanazt az értéket hozzárendelhetjük különböző elemekhez.
        </para>
        <para>
            IV. heti előadás (46. oldal, az "3. Kifejezések" című rész):
        </para>
        <para>
            A kifejezések szintaktikai eszközök. A kifejezések operandusokból, operátorokból és kerek zárójelekből állnak. Létezik egyoperandusú, kétoperandusú és háromoperandusú operátor, melyek attól függnek, hogy hány operandussal végzi a mőveletet az operátor. A kifejezéseknek 3 alakja lehet: a prefix, az infix és a postfix. Kifejezés kiértékelésének nevezzük azt a folyamatot mikor a kifejezés értéke és a típusa meghatározódik. A kifejezések két típusa: a típusegyenértékűség és a típuskényszerítés. 
        </para>
        <para>
            V. heti előadás (56. oldal, az "4. Utasítások" című rész):
        </para>
        <para>
            Az utasítások megalkotják a programok egységeit. Két csoportjuk van: a deklarációs utasítások illetve végrehajtó utasítások. A deklarációs utasítások a fordítóprogramnak szólnak. A végrehajtó utasításokból a fordító generálja a kódot. A végrehajtó utasításokat csoportosíthatjuk többféle képpen: értékadó utasítás, üres
            utasítás, ugró utasítás, elágaztató utasítás, ciklusszervező utasítás, hívó utasítás, vezérlésátadó utasítás, I/O utasítás, egyéb utassítás. Vezérlési szerkezetet megvalósító utasítások a következőek: ugró utasítás, elágaztató utasítás, ciklusszervező utasítás, hívó utasítás, vezérlésátadó utasítás.
        </para>
        <para>
            VII. heti előadás (78-84. oldal):
        </para>
        <para>
            A paraméterátadásnak többféle képpen is történhet, ezek nyelvfüggőek. 
            Történhet érték szerint, mint a C-ben például. Ekkor az aktuális paraméter értékét kapja a formális paraméter. Ilyenkor a függvényben nem lehet megváltoztatni a paraméter értékét. Lehet címszerinti a paraméterátadás. Ekkor a formális paraméter címe kapja az aktuális paraméter címét. Itt a függvényben meg lehet változtatni az aktuális paraméter értékét.Eredmény szerinti átadás esetén, a formális paraméter szintén megkapja az aktuális paramétert, de nem használja, hanem beletölti az adatokat. Létezik még érték-eredmény szerinti, ekkor is másolódik a cím illetve használja is az adatokat és a függvény végén belemásolja az adatokat.
        </para>
        <para>
            VIII. heti előadás (98. oldal, a "Absztrakt adattípus" című rész):
        </para>
        <para>
            Az absztrakt adatttípus olyan adattípus, amely megvalósítja a bezárást vagy információ rejtést. Az ilyen típusú programozás művelethez a specifikációi által meghatározott interfészen keresztül férhetük hozzá ezért az értékeket véletlenül vagy szándékosan nem ronthatjuk el. 
        </para>
        <para>
            VIII. heti előadás (121. oldal, a "Generikus programozás" című rész):
        </para>
        <para>
            A generikus programozás az újrafelhasználhatóság és a procedurális absztrakció eszköze. Lényege: Megadunk egy paraméterezhető forrásszövegmintát ami fordítási időben lesz kezelve lesz majd kezelve. A mintaszöveg segítségével előállítható egy lefordítható konkrét szöveg. Az újrafelhasználás alatt azt értjük, hogy egy mintaszövegből bármennyi szöveg generálható. A generikus formális paramétereinek száma mindig fix. A paraméterkiértékelésnél a kötés az alapértelmezett, de alkalmazható a név szerinti kötés is. 
        </para>
           
    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para>
        <para>
            V.heti előadás (Vezérlési szerkezetek című fejezet):
        </para>
        <para>
            Egy nyelv vezérlésátadó utasításai a műveletek végrehajtási sorrendjét határozzák meg. A C nyelvben a ; az utasításlezáró jel. A kapcsos zárójelekkel deklarációk és utasítások csoportját fogjuk össze egyetlen összetett blokba. Az "if-else" utasítás döntés kifejezésére használjuk, az utasítás először 
            kiértékeli a kifejezést, és ha igaz, akkor az első utasítást hajtja végre de ha a kifejezés értéke viszont nem igaz, akkor az "else" ág fut le. Általános szabály, hogy az "else" mindg a legközelebbi "if"-hez tartozik. A "switch" utasítás is a többirányú programelágazás egyik eszköze, összehasonlítja egy kifejezés értékét több egész értékű állandó kifejezés értékével és annak megfelelő utasítást hajtja végre. A "while - for" szerkezet először kiértékeli a kifejezést, ha ennek az értéke nem nulla, akkor végrehajtja az utasítást. Ez addig ismétlődik, amíg nulla nem lesz a kifejezé. A "do - while" szerkezet először végrehajtja az utasítást,és csak utána értékeli ki a kifejezést. Ha a kifejezés értéke igaz, akkor az utasítást újból végrehajtja. Ez addig ismétlődik, amíg a kifejezés értéke hamis lesz. A "break" lehető teszi, hogy elhagyjuk a ckliusokat idő előtt. A "goto" utasítás előnyös, ha ki akarunk lépni egy több szinten egymásba ágyazott ciklusból.
        </para>       
        <para>
            V.heti előadás (Függelékből az Utasítások című fejezet):
        </para>
        <para>
            Az utasítások a leírásuk sorrendjében hajtódnak végre, általános a szintaktikai leírásuk, és számos csoportba sorolhatók: Címkézett utasítások, mint például a "case" és "default" címkéi a "switch" utasítással használhatók. A címke egy azonosító nélküli deklarált azonosítóból áll. Kifejezésutasítsok, az utasítások(kifejezésutasítás, értékadás, függvényhívás) többsége ilyen. Összetett utasítás, több utasítást egyetlen
            utasításként kezeli, ez a fordításhoz szükséges, mivel sok fordítóprogram csak egyetlen utasítást fogad el. Kiválasztott utasítások, minden esetben a ehetséges végrehajtási sorrendek egyikét választják ki(if, if-else, switch). Iterációs utasítások, egy ciklust határoznak meg(while, do-while, for). Vezérlésátadó utasítások, vezérlés feltétel nélküli átadására alkalmasak(goto, continue, break, return).
        </para>   
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para>
            V.heti előadás (1.-16.):
        </para>
        <para>
            A C++ a C-nek a továbbfejlesztése. A C++ sok problémára biztonságosabb, és kényelmesebb megoldást kínál, mint a C. C-ben üres paraméterlistával definiálunnk, akkor az tetszőleges számú paramáéterrel hívható. A C++-ban azonban az üres paraméterlista egy "void" paraméter megadásával ekvivalens. C nyelvben is
            létezik több bájtos sztring. C++-ban miinden olyan helyen állhat változódeklaráció, ahol utasítás állhat. A C nyelvben a neve azonosít egy függvényt, C++-ban viszont a függvényeket a nevük, és az argumentumlistájuk azaonosítja. Míg a C nyelv úgy hivatkozik egy függvényre a linker szintjén, hogy egy aláhúzást tesz
            a függvénynevek elé, addig a C++ az egyes fordítókra bízza a névferdítés implementálását. Cím szerinti paraméterátadás, ha a változó címét adjuk át, ebebn az esetben nem tudjuk megváltoztatni úgy a változót, hogy az értéke megmaradjon. Az érték szerinti paraméteradásnál viszont, készül másolat a változóról, így végezhetünk műveleteket úgy, hogy a változó értékét nem befolyásoljuk. A C++ referenciatípus bevezetése feleselgessé teszi a pointerek cím szerinti pareméterátadását.
        </para> 
        <para>
            VI. heti előadás (17-58.):
        </para>
        <para>
            Ez a fejezet a C++ osztályairól szól.     
            Az objektum orientált programozás alapelve, hogy a probléma megoldását segítse azzal, hogy az emberi gondolkodáshoz közelebb hozza a programozást az osztályok és objektumok bevezetésével. Az egységbe zárás jelenti azt, hogy az összetartozó változók és függvények egy egységben legyen, ezek lesznek az adattagok és a tagfüggvények. Adatrejtés a private és protected adattagok és tagfüggvények bevezetésével jött létre. Az adatrejtés célja, hogy az osztály egyes tagjait ne lehessen kívülről elérni. A konstruktor szerepe, hogy lefusson, amikor létrejön az objektum, ezáltal akár inicializálva az adattagokat. A destruktor célja, hogy lefusson, amikor az objektum megsemmisül, ezáltal akár felszabadítva a diamikus adattagokat. A dinamikus adattagok osztályon belüli pointerek, amelyeket futásidőben hozzuk létre dinamikus memóriafoglalással, ezért ezeket, ha már nincs rájuk szükség, de legkésőbb a destruktorban fel kell szabadítani. A friend osztályok, illetve függvények olyan osztályok, illetve függvénynek, amelyek ugyan nem tagjai az osztálynak, viszont hozzáférnek azok private tagjaihoz. A tagváltozók inicializálása történhet a konstruktoron belül, illetve tagfüggvénnyel, vagy külső függvénnyel is. A statikus tagok azzal a tulajdonsággal rendelkeznek, hogy nem kell az osztályt példányosítani, hogy használni tudjuk. Az osztályok tartalmazhatnak beágyazott definíciókat, amelyek lehetnek enumerációk, struktúrák vagy akár osztályok is.
        </para>
        <para>
            VII. heti előadás (93-96.):
        </para>
        <para>
            Ez a fejezet az operátokról és azok túlterheléséről szól C++ nyelvben. Az operátorok alapértelmézés szerint az argumentumain hadjtanak végre műveletet, amelyek visszatérési értékével tudunk dolgozni. C++-ban nem lehet új operátorokat létrehozni, azonban majdnem mindet túl lehet terhelni. A túlterhelés célja, hogy bizonyos operátorokat más célra használhassunk, mint az erdeti célja, a programozás megkönnyítése céljából, mint például a bitshift operátor túlterhelése az alapértelmezett IO objektumoknál.
        </para>
    </section>        
</chapter> 
